using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace UpdateService
{
    class UpdatePackage
    {
        private byte[] mUpdateData;
        static byte XOR_KEY = 0x93;
        static byte[] MAGIC = {0x53,0x55,0x75,0x73};

        static private byte[] ExtractData(byte[] HashAndData)
        {
            //Read SHA1 hash and then read rest of data an hash it
            SHA1Managed sha = new SHA1Managed();
            byte[] providedsha1hash = new byte[20];
            byte[] extractedData = new byte[HashAndData.Length-20];

            if (HashAndData.LongLength < 20)
            {
                //Not enough data for hash
                return null;
            }

            Array.Copy(HashAndData, providedsha1hash, 20);
            Array.Copy(HashAndData,20,extractedData,0,extractedData.Length);

            //Generate the sha1 hash for the data
            byte[] calculatedsha1hash = sha.ComputeHash(extractedData);

            //Are they the same length
            if (providedsha1hash.Length != calculatedsha1hash.Length)
                return null;

            //Compare the array
            for (int i = 0; i < calculatedsha1hash.Length;i++)
            {
                if (calculatedsha1hash[i] != providedsha1hash[i])
                    return null;
            }
            
            //No bailout, means they match
            return extractedData;
        }
        static internal UpdatePackage FromData(byte[] UpdateData)
        {
            //Data package format is 
            // <SHA1HASH(20 bytes)>
            // <XORED DATA>
            //   <MAGIC(4 bytes)>
            //   <DATA(n bytes)>
            // </ENCRYPTED DATA>

            //Remove the XOR Coding on all the data
            try
            {
                for (int i = 0; i < UpdateData.Length; i++)
                    UpdateData[i] ^= XOR_KEY;

                byte[] updaterData = ExtractData(UpdateData);
                if (updaterData == null)
                    return null;

                //Check Magic
                if (updaterData.Length < MAGIC.Length)
                    return null;

                for (int i = 0; i < MAGIC.Length; i++)
                {
                    if (updaterData[i] != MAGIC[i])
                        return null;
                }

                byte[] packageData = new byte[updaterData.Length - 4];
                Array.Copy(updaterData, 4, packageData, 0, updaterData.Length - 4);

                UpdatePackage up = new UpdatePackage(packageData);

                return up;
            }
            catch
            {
                return null;
            }
        }
        
        private UpdatePackage(byte[] ValidData)
        {
            this.mUpdateData = ValidData;
        }

        internal string WriteUpdaterToDisk()
        {          
            //Create a temp file
            string tempFilename;
            try {
                tempFilename = Path.GetTempFileName();
            }
            catch (Exception){
                return null;
            }

            try
            {
                using (FileStream fs = new FileStream(tempFilename, FileMode.Open, FileAccess.ReadWrite))
                {
                    using (BinaryWriter bw = new BinaryWriter(fs))
                    {
                        bw.Write(this.mUpdateData);
                        bw.Close();
                    }

                }
            }catch (Exception)
            { 
                //Remove the file
                File.Delete(tempFilename);
                return null;
            }

            return tempFilename;            
        }

        internal bool ExecuteUpdater()
        {
            //Place the executable onto the disk
            string updaterFileName = null;

            try
            {
                updaterFileName = this.WriteUpdaterToDisk();

                if (updaterFileName == null)
                {
                    return false;
                }

                ProcessStartInfo psi = new ProcessStartInfo(updaterFileName);
                psi.UseShellExecute = false;

                Process updaterProcess = Process.Start(psi);
                //XXX: We deliberatly don't attempt to cleanup the temp exec files, so that we don't need to wait for users to try again.
                //     However this means if they create more that 65535 files, they will need to delete the files (i.e Reimage the machine).
                if (updaterProcess == null)
                    return false;

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

    }
}
