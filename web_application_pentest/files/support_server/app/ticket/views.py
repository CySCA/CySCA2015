from flask import Blueprint, request, render_template, flash, g
from flask import redirect, url_for, make_response, abort, jsonify
from sqlalchemy.exc import SQLAlchemyError

from app import app, db
from app.ticket.models import *
from app.ticket import constants as TICKET

mod = Blueprint('ticket', __name__, url_prefix='/ticket')

@mod.errorhandler(400)
def invalid(error):
    return make_response(jsonify({'error': 'invalid request'}), 400)

@mod.errorhandler(401)
def no_auth(error):
    return make_response(jsonify({'error': 'invalid credentials'}), 401)

@mod.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'not found'}), 404)

def error(code):
    if code == 666:
        return make_response(jsonify({ 'error': str(g.error) }))
    else:
        abort(code)


@app.before_request
def before_request():
    g.error = ''
    try:
        uid = request.json['uid']
        secret = request.json['secret']
        if uid == 'ecwi_webserver' and secret == '&godModeActivated007^':
            g.uid = 0
        else:
            # <<< BEGIN SQL INJECTION >>>
            cmd  = 'SELECT uid, secret from ecwidb_tokens '
            cmd += 'WHERE uid="%s" ' % str(uid)
            cmd += 'AND secret="%s";' % secret
            try:
                token = db.engine.execute(cmd).first()
            except SQLAlchemyError as e:
                g.error = e
            # <<< ENDOF SQL INJECTION >>>
            g.uid = token.uid
    except:
        g.uid = -1


def validate(fields=[], restrict=False):
    if g.error != '':
        return 666
    if g.uid < 0 or (restrict and g.uid != 0):
        return 401
    if not request.json and len(fields) > 0:
        return 400
    for f in fields:
        if f not in request.json:
            return 400
    return 0


@mod.route('/get', methods=['POST'])
def get_tickets():
    err = validate()
    if not err:
        if g.uid == 0:
            tickets = Ticket.query.all()
        else:
            tickets = Ticket.query.filter_by(owner=g.uid)
        return jsonify(tickets=[t.summary for t in tickets])
    return error(err)


@mod.route('/get/<ticket_id>', methods=['POST'])
def get_ticket(ticket_id):
    err = validate()
    if not err:

        # <<< BEGIN SQL INJECTION >>>
        #cmd  = 'SELECT * from ecwidb_tickets '
        #cmd += 'WHERE id="%s" ' % str(ticket_id)
        #cmd += 'AND owner="%s" ' % str(g.uid)
        #try:
        #    tickets = db.engine.execute(cmd)
        #except SQLAlchemyError as e:
        #    g.error = e
        #    return error(666)

        #ticketList = []
        #for ticket in tickets:
        #    t = Ticket.query.get(ticket.id)
        #    ticketList.append(t.serialize)

        #if len(ticketList) > 0:
        #    return jsonify(ticket=ticketList)
        # <<< ENDOF SQL INJECTION >>>

        ticket = Ticket.query.get(ticket_id)
        if ticket:
            return jsonify(ticket=[ticket.serialize])
        else:
            abort(404)
    return error(err)


@mod.route('/new', methods=['POST'])
def new_ticket():
    err = validate(['title', 'issue'])
    if not err:
        add_ticket(g.uid,
                   request.json['title'],
                   request.json['issue'])
        return jsonify({ 'result': True }), 201
    return error(err)


@mod.route('/reply/<ticket_id>', methods=['POST'])
def new_reply(ticket_id):
    err = validate(['author', 'message'])
    if not err:
        add_reply(ticket_id,
                  request.json['author'],
                  request.json['message'])
        return jsonify({ 'result': True }), 201
    return error(err)


@mod.route('/token', methods=['POST'])
def new_token():
    err = validate(['token_uid', 'token_secret'], restrict=True)
    if not err:
        add_token(request.json['token_uid'],
                  request.json['token_secret'])
        return jsonify({ 'result': True }), 201
    return error(err)


@mod.route('/token/get', methods=['POST'])
def get_tokens():
    err = validate(restrict=True)
    if not err:
        tokens = Token.query.all()
        return jsonify(tokens=[t.serialize for t in tokens])
    return error(err)
