#!/usr/bin/env python
from gevent import monkey
monkey.patch_all()

import os, subprocess
from flask import Flask
from flask.ext.socketio import SocketIO, emit, disconnect
from flask.ext.cors import CORS

app = Flask(__name__)
app.debug = False
app.config['SECRET_KEY'] = 'superSecretSquirrel2015!'
cors = CORS(app)
socketio = SocketIO(app)

termroot = '/var/www/ecwi/term/termroot'

def sanitise_filename(filename, testing=False):
    if filename.startswith('/'):
        filename = filename[1:]
    f1 = os.path.join(termroot, filename)
    f2 = os.path.abspath(f1)
    prefix = termroot + '/'
    if f2.startswith(prefix):
        f = f2[len(prefix):]
    else:
        f = '[invalid_path]'
    if testing:
        print '%-18s' % filename, '%-36s' % f2, '%-20s' % f
    return f


def fpath(filename):
    return termroot + '/' + filename


def run(cmd, args=[]):
    cmd = [ termroot + '/bin/' + cmd ]
    print '[run] %s' % ' '.join(cmd + args)
    try:
        return subprocess.check_output(cmd + args, shell=False,
                stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError, e:
        return '[error] ' + e.output.decode('utf-8')


class Shell(object):

    def __init__(self):
        self.admin = False
        self.logging = False
        self.logfile = '.log'
        self.passfile = '.passwd'

    def usage(self):
        s  = 'AVAILABLE COMMANDS:\n'
        s += 'help                  display this information\n'
        s += 'id                    show user id\n'
        s += 'ps                    list active processes\n'
        s += 'ip                    list network interfaces\n'
        s += 'rm                    delete file\n'
        s += 'ln &lt;src&gt; &lt;dst&gt;        create symlink (admins only)\n'
        s += 'ls                    list directory entries\n'
        s += '  -s                  view file size information\n'
        s += '  -h                  view hidden files\n'
        s += 'uname                 show system information\n'
        s += 'auth &lt;password&gt;       authenticate as administrator\n'
        s += 'log &lt;outfile&gt;         append next command output to file\n'
        s += 'reset                 reset to initial terminal state\n'
        return s

    def log(self, msg):
        msg = msg.rstrip()
        if self.logging:
            with open(fpath(self.logfile), 'a') as f:
                f.write(msg)
            self.logging = False
        return msg

    def execute(self, cmd):
        args = cmd.split()
        c = args[0]

        if c == 'ip':
            return self.cmd_ip(args)

        elif c == 'ln':
            if not self.admin:
                return '[auth] \'ln\' is a privileged command (requires admin account)'
            if len(args) != 3:
                return 'Usage: %s &lt;src&gt &lt;dst&gt;' % c
            return self.cmd_ln(args)

        elif c == 'ps':
            return self.cmd_ps(args)

        elif c == 'uname':
            return self.cmd_uname(args)

        elif c == 'auth':
            if len(args) != 2:
                return 'Usage: %s &lt;password&gt;' % c
            return self.cmd_auth(args)

        elif c == 'reset':
            os.system('/var/www/ecwi/term/reset.sh')
            self.admin = False
            self.logging = False
            return 'done.'

        elif c == 'rm':
            if len(args) != 2:
                return 'Usage: %s &lt;filename&gt;' % c
            return self.cmd_rm(args)

        elif c == 'ls':
            return self.cmd_ls(args)

        elif c == 'id':
            return self.cmd_id(args)

        elif c == 'log':
            if len(args) != 2:
                return 'Usage: %s &lt;outfile&gt;' % c
            return self.cmd_log(args)

        elif c == 'help' or c == '?':
            return self.usage()

        else:
            return 'ERROR: command not found'

    def cmd_ip(self, args):
        return self.log(run('ip'))

    def cmd_id(self, args):
        return self.log(run('bash', [fpath('bin/id.sh')]))

    def cmd_ln(self, args):
        src = sanitise_filename(args[1])
        dst = sanitise_filename(args[2])
        if not os.path.exists(fpath(src)):
            return self.log('ln: &lt;src&gt; no such file or directory')
        elif os.path.exists(fpath(dst)):
            return self.log('ln: &lt;dst&gt; no such file or directory')
        return self.log(run('ln', [src, dst]))

    def cmd_rm(self, args):
        f = sanitise_filename(args[1])
        if os.path.exists(fpath(f)) and not os.path.isdir(fpath(f)):
            return self.log(run('rm', [f])).rstrip()
        else:
            s = 'rm: cannot remove "%s": ' % f
            s += 'No such file or it is a directory'
            return s

    def cmd_ls(self, args):
        flags = []
        path = False
        for arg in args[1:]:
            if arg == '-h':
                flags.append('-a')
            elif arg == '-s':
                flags.append('-l')
            elif not arg.startswith('-') and not path:
                f = sanitise_filename(arg)
                flags.append(f)
                path = True
            else:
                pass
        return self.log(run('ls', flags))

    def cmd_ps(self, args):
        return self.log(run('ps'))

    def cmd_uname(self, args):
        return self.log(run('uname'))

    def cmd_auth(self, args):
        try:
            admin_pass = open(fpath(self.passfile), 'r').read().rstrip()
        except:
            return self.log('[auth] unable to load password file')
        if admin_pass == args[1]:
            self.admin = True
            return self.log('[auth] admin login successful!')
        else:
            return self.log('[auth] incorrect admin password')

    def cmd_log(self, args):
        f = sanitise_filename(args[1])
        if 'bin' not in f:
            self.logging = True
            self.logfile = f
            s = '[log] next command output will be saved to %s'
            return s % self.logfile
        else:
            return 'log: invalid log file, can\'t use bin directory'


#
# GLOBAL SHELL INSTANCE
#

shell = Shell()


@socketio.on('run_command')
def run_command(msg):
    global shell
    try:
        cmd = msg['data'].lower()
        output = '> %s\n' % cmd
        output += shell.execute(cmd)
        emit('client_recv', { 'data': output })
    except Exception as e:
        emit('client_recv', { 'data': 'ERROR: an exception occurred' })
        shell.logging = False
        print '[error]', e


@socketio.on('client_connect')
def term_connect():
    emit('client_recv', { 'data': '[connect]' })


if __name__ == '__main__':
    if app.debug:
        tests = [
            'bin', '/bin', 'bin/', '/bin/',
            'etc', '/etc', 'etc/', '/etc/'
            'bin/..', '/bin/..', 'bin/../', '/bin/../',
            '..', '/..', '../', '/../',
            '.', '/.', './', '/./',
            '/var/www/ecwi', '/var/www/ecwi/', '/',
            '.flag', '/.flag', '.flag/', '/.flag/',
            'bin/../.flag', '/bin/../.flag', './.flag',
            '../termroot/.flag', '/var/www/ecwi/term/termroot/.flag'
        ]
        for t in tests:
            sanitise_filename(t, True)
    socketio.run(app, host='0.0.0.0', port=9447)
